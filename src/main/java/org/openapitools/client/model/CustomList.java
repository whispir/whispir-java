/*
 * Whispir Platform API
 * Whispir Platform API for cross channel and multi channel communications. Documentation on each endpoint is available at https://developers.whispir.com.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: support@whispir.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.client.model.CustomListCustomlabellistsInner;
import org.openapitools.client.model.LinkInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import whispir_sdk_java.JSON;

/**
 * A custom list is a predefined list of options that can be inserted into a message or template. A list might be made up of capital city names, days of the week, incident types, business phone numbers and so on. Custom lists make it easy to add information quickly and consistently to your message content.
 */
@ApiModel(description = "A custom list is a predefined list of options that can be inserted into a message or template. A list might be made up of capital city names, days of the week, incident types, business phone numbers and so on. Custom lists make it easy to add information quickly and consistently to your message content.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-21T01:55:16.197234Z[Etc/UTC]")
public class CustomList {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * Specifies the type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    INCIDENT("INCIDENT"),
    
    MESSAGE("MESSAGE"),
    
    CONTACT("CONTACT"),
    
    RSS("RSS");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private String createdDate;

  /**
   * Specifies the sorting order
   */
  @JsonAdapter(SortTypeEnum.Adapter.class)
  public enum SortTypeEnum {
    AS_DISPLAYED("As Displayed"),
    
    ASCENDING("Ascending"),
    
    DESCENDING("Descending");

    private String value;

    SortTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SortTypeEnum fromValue(String value) {
      for (SortTypeEnum b : SortTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SortTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SortTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SortTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SortTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SORT_TYPE = "sortType";
  @SerializedName(SERIALIZED_NAME_SORT_TYPE)
  private SortTypeEnum sortType;

  /**
   * Specifies the linked status. When enabled the value selected for one channel is automatically applied on the other channels.
   */
  @JsonAdapter(LinkedEnum.Adapter.class)
  public enum LinkedEnum {
    DISABLED("disabled"),
    
    ENABLED("enabled");

    private String value;

    LinkedEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LinkedEnum fromValue(String value) {
      for (LinkedEnum b : LinkedEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LinkedEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LinkedEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LinkedEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LinkedEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LINKED = "linked";
  @SerializedName(SERIALIZED_NAME_LINKED)
  private LinkedEnum linked;

  public static final String SERIALIZED_NAME_CUSTOMLABELLISTS = "customlabellists";
  @SerializedName(SERIALIZED_NAME_CUSTOMLABELLISTS)
  private List<CustomListCustomlabellistsInner> customlabellists = null;

  public static final String SERIALIZED_NAME_LINK = "link";
  @SerializedName(SERIALIZED_NAME_LINK)
  private List<LinkInner> link = new ArrayList<>();

  public CustomList() { 
  }

  
  public CustomList(
     String id, 
     String name, 
     TypeEnum type, 
     String createdDate, 
     SortTypeEnum sortType, 
     LinkedEnum linked, 
     List<CustomListCustomlabellistsInner> customlabellists, 
     List<LinkInner> link
  ) {
    this();
    this.id = id;
    this.name = name;
    this.type = type;
    this.createdDate = createdDate;
    this.sortType = sortType;
    this.linked = linked;
    this.customlabellists = customlabellists;
    this.link = link;
  }

   /**
   * Specifies the unique ID of the list
   * @return id
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "4B4625BAEB7E4D58", required = true, value = "Specifies the unique ID of the list")

  public String getId() {
    return id;
  }




   /**
   * Specifies the name of the list
   * @return name
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "Day of Week", required = true, value = "Specifies the name of the list")

  public String getName() {
    return name;
  }




   /**
   * Specifies the type
   * @return type
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "MESSAGE", required = true, value = "Specifies the type")

  public TypeEnum getType() {
    return type;
  }




   /**
   * Specifies the creation date of the list
   * @return createdDate
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "09/06/15 10:18", required = true, value = "Specifies the creation date of the list")

  public String getCreatedDate() {
    return createdDate;
  }




   /**
   * Specifies the sorting order
   * @return sortType
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "As Displayed", required = true, value = "Specifies the sorting order")

  public SortTypeEnum getSortType() {
    return sortType;
  }




   /**
   * Specifies the linked status. When enabled the value selected for one channel is automatically applied on the other channels.
   * @return linked
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(example = "enabled", required = true, value = "Specifies the linked status. When enabled the value selected for one channel is automatically applied on the other channels.")

  public LinkedEnum getLinked() {
    return linked;
  }




   /**
   * Contains the individual items that make up this list
   * @return customlabellists
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Contains the individual items that make up this list")

  public List<CustomListCustomlabellistsInner> getCustomlabellists() {
    return customlabellists;
  }




   /**
   * A [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) link object, describing all discoverable resources in relation to the original request.
   * @return link
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) link object, describing all discoverable resources in relation to the original request.")

  public List<LinkInner> getLink() {
    return link;
  }





  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CustomList customList = (CustomList) o;
    return Objects.equals(this.id, customList.id) &&
        Objects.equals(this.name, customList.name) &&
        Objects.equals(this.type, customList.type) &&
        Objects.equals(this.createdDate, customList.createdDate) &&
        Objects.equals(this.sortType, customList.sortType) &&
        Objects.equals(this.linked, customList.linked) &&
        Objects.equals(this.customlabellists, customList.customlabellists) &&
        Objects.equals(this.link, customList.link);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, type, createdDate, sortType, linked, customlabellists, link);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CustomList {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    sortType: ").append(toIndentedString(sortType)).append("\n");
    sb.append("    linked: ").append(toIndentedString(linked)).append("\n");
    sb.append("    customlabellists: ").append(toIndentedString(customlabellists)).append("\n");
    sb.append("    link: ").append(toIndentedString(link)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("name");
    openapiFields.add("type");
    openapiFields.add("createdDate");
    openapiFields.add("sortType");
    openapiFields.add("linked");
    openapiFields.add("customlabellists");
    openapiFields.add("link");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("type");
    openapiRequiredFields.add("createdDate");
    openapiRequiredFields.add("sortType");
    openapiRequiredFields.add("linked");
    openapiRequiredFields.add("link");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to CustomList
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (CustomList.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in CustomList is not found in the empty JSON string", CustomList.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!CustomList.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CustomList` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CustomList.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (jsonObj.get("id") != null && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (jsonObj.get("name") != null && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if (jsonObj.get("createdDate") != null && !jsonObj.get("createdDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdDate").toString()));
      }
      if (jsonObj.get("sortType") != null && !jsonObj.get("sortType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sortType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sortType").toString()));
      }
      if (jsonObj.get("linked") != null && !jsonObj.get("linked").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `linked` to be a primitive type in the JSON string but got `%s`", jsonObj.get("linked").toString()));
      }
      JsonArray jsonArraycustomlabellists = jsonObj.getAsJsonArray("customlabellists");
      if (jsonArraycustomlabellists != null) {
        // ensure the json data is an array
        if (!jsonObj.get("customlabellists").isJsonArray()) {
          throw new IllegalArgumentException(String.format("Expected the field `customlabellists` to be an array in the JSON string but got `%s`", jsonObj.get("customlabellists").toString()));
        }

        // validate the optional field `customlabellists` (array)
        for (int i = 0; i < jsonArraycustomlabellists.size(); i++) {
          CustomListCustomlabellistsInner.validateJsonObject(jsonArraycustomlabellists.get(i).getAsJsonObject());
        };
      }
      JsonArray jsonArraylink = jsonObj.getAsJsonArray("link");
      if (jsonArraylink != null) {
        // ensure the json data is an array
        if (!jsonObj.get("link").isJsonArray()) {
          throw new IllegalArgumentException(String.format("Expected the field `link` to be an array in the JSON string but got `%s`", jsonObj.get("link").toString()));
        }

        // validate the optional field `link` (array)
        for (int i = 0; i < jsonArraylink.size(); i++) {
          LinkInner.validateJsonObject(jsonArraylink.get(i).getAsJsonObject());
        };
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CustomList.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CustomList' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CustomList> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CustomList.class));

       return (TypeAdapter<T>) new TypeAdapter<CustomList>() {
           @Override
           public void write(JsonWriter out, CustomList value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CustomList read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of CustomList given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CustomList
  * @throws IOException if the JSON string is invalid with respect to CustomList
  */
  public static CustomList fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CustomList.class);
  }

 /**
  * Convert an instance of CustomList to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

