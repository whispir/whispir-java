/*
 * Whispir Platform API
 * Whispir Platform API for cross channel and multi channel communications. Documentation on each endpoint is available at https://developers.whispir.com.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whispir.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.whispir.api;

import whispir_sdk_java.ApiException;
import java.math.BigDecimal;
import org.openapitools.client.model.Callback;
import org.openapitools.client.model.GetCallbackInstances200Response;
import org.openapitools.client.model.GetCallbacks200Response;
import org.openapitools.client.model.GetMessages400Response;
import org.openapitools.client.model.GetMessages401Response;
import org.openapitools.client.model.GetMessages403Response;
import org.openapitools.client.model.GetMessages404Response;
import org.openapitools.client.model.GetMessages405Response;
import org.openapitools.client.model.GetMessages415Response;
import org.openapitools.client.model.GetMessages422Response;
import org.openapitools.client.model.GetMessages500Response;
import org.openapitools.client.model.GetMessages501Response;
import org.openapitools.client.model.PutCallbackInstanceStatusRequest;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for CallbacksApi
 */
@Disabled
public class CallbacksApiTest {

    private final CallbacksApi api = new CallbacksApi();

    /**
     * Delete a callback
     *
     * Delete a callback object
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteCallbackByIdTest() throws ApiException {
        String xApiKey = null;
        String callbackId = null;
        String contentType = null;
        String accept = null;
        api.deleteCallbackById(xApiKey, callbackId, contentType, accept);
        // TODO: test validations
    }

    /**
     * Get a callback
     *
     * Get a callback object
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCallbackByIdTest() throws ApiException {
        String xApiKey = null;
        String callbackId = null;
        String accept = null;
        Callback response = api.getCallbackById(xApiKey, callbackId, accept);
        // TODO: test validations
    }

    /**
     * List callback instances
     *
     * Get a list of callbacks instances
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCallbackInstancesTest() throws ApiException {
        String xApiKey = null;
        String callbackId = null;
        String accept = null;
        BigDecimal limit = null;
        BigDecimal offset = null;
        String sortOrder = null;
        String sortFields = null;
        String status = null;
        GetCallbackInstances200Response response = api.getCallbackInstances(xApiKey, callbackId, accept, limit, offset, sortOrder, sortFields, status);
        // TODO: test validations
    }

    /**
     * List callbacks
     *
     * List callbacks 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCallbacksTest() throws ApiException {
        String xApiKey = null;
        String accept = null;
        BigDecimal limit = null;
        BigDecimal offset = null;
        String sortOrder = null;
        String sortFields = null;
        GetCallbacks200Response response = api.getCallbacks(xApiKey, accept, limit, offset, sortOrder, sortFields);
        // TODO: test validations
    }

    /**
     * Create a callback
     *
     * Whispir’s callback service can be configured to send simple notifications and some associated metadata via API callbacks to an endpoint of your choice when one of the following events occurs:  - A message has been replied to - A message delivery failure occurred [wrong number or service unavailable]  &gt; **IMPORTANT**: unlike all the other API endpoints seen so far, Callbacks are not defined at a Workspace level but at a Company level. In other words, they can be referenced from any Workspace of that Company.  Callbacks are used widely in web applications to transfer information that may become available at some point in the future. These are sometimes referred to as ‘webhooks’.  The benefits of using API callbacks are: - Whispir will instantly notify your callback server when a change has occurred on Whispir platform. - You won&#39;t need to continuously poll the &#x60;/messageresponses&#x60; or &#x60;/messagestatus&#x60; endpoints, so you won&#39;t be reducing your API daily cap. - Callbacks themselves are on us, so they do not count towards the daily quota limits. - Response-based workflows can be built quickly and effectively.  The following diagram explains the entire high-level process: ![API diagram](https://github.com/whispir/openapi/blob/main/assets/images/Whispir_API_diagram.png?raw&#x3D;true)  ## Callback endpoint validation During callback creation, Whispir makes a &#x60;GET&#x60; request to ensure the callback &#x60;url&#x60; provided is valid and available. The HTTP response code returned by the callback endpoint for this request must be &#x60;200&#x60;. Any other code is considered a failure and the callback creation will fail. This is the only time a &#x60;GET&#x60; request is made. Subsequent requests (callbacks) will all be &#x60;POST&#x60; requests.  ## Configuration tips  - Always use a domain name for the callback. Do not use an IP. - Ensure that your callback server is reachable on the internet. It should not be localhost or an intranet-only application that can&#39;t be reached from the World Wide Web. - Limit the port to 80 or 443. Do not use any other ports. - Depending on the type chosen (‘json’ or ‘xml’) for the Content-Type, Whispir would make a similar &#x60;GET&#x60; (and subsequently &#x60;POST&#x60;) call. Ensure that your web server is configured to handle such MIME types. - Most importantly, if your application infrastructure is behind a firewall, make sure that the firewall allows an incoming &#x60;POST&#x60; request.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void postCallbacksTest() throws ApiException {
        String xApiKey = null;
        String contentType = null;
        String accept = null;
        Callback callback = null;
        Callback response = api.postCallbacks(xApiKey, contentType, accept, callback);
        // TODO: test validations
    }

    /**
     * Update a callback
     *
     * Update a callback object
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void putCallbackByIdTest() throws ApiException {
        String xApiKey = null;
        String callbackId = null;
        String contentType = null;
        String accept = null;
        Callback callback = null;
        api.putCallbackById(xApiKey, callbackId, contentType, accept, callback);
        // TODO: test validations
    }

    /**
     * Update a callback instance status
     *
     * As every call to a callback endpoint is now stored within the calls endpoint, it’s possible that when failed calls are successfully processed through a manual exercise, that these calls will then need to be updated to reflect the current status.  Take the following example: 1.  Callback server becomes unavailable 2.  A message is sent via Whispir with callbacks enabled. 3.  The Message gets a response, and this triggers the callback 4.  The callback server is unavailable, so the response is stored with a status of &#39;FAILED’ 5.  After 24h, the callback server becomes available again. Retries have stopped, so this information will not automatically flow into the callback server. 6.  The customer writes a script to GET all of the calls stored in the /calls endpoint and process them. 7.  Once successfully processed, the customer’s script should update the contents of the /calls endpoint to reflect the current status of &#39;SUCCESS’.  This process can be facilitated with the use of a PUT request to the /calls endpoint in Whispir.  To update a list of attempted API calls from the Whispir API you can execute an HTTP PUT using the /calls endpoint on a specific callback.  Users can specify multiple IDs to be updated using the following notation:  &#x60;/callbacks/:id/calls?id&#x3D;ID1&amp;id&#x3D;ID2&amp;id&#x3D;ID3...&#x60;  This ensures that all callbacks that have been processed can be updated in a single API call, rather than having to make a single API call per callback attempt.  The PUT request takes a single API parameter in the body 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void putCallbackInstanceStatusTest() throws ApiException {
        String xApiKey = null;
        String callbackId = null;
        String contentType = null;
        String accept = null;
        String id = null;
        PutCallbackInstanceStatusRequest putCallbackInstanceStatusRequest = null;
        api.putCallbackInstanceStatus(xApiKey, callbackId, contentType, accept, id, putCallbackInstanceStatusRequest);
        // TODO: test validations
    }

}
